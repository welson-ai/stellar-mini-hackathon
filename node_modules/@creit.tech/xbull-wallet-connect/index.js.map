{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { box, randomBytes } from 'tweetnacl';\nimport { decodeBase64, decodeUTF8, encodeBase64, encodeUTF8 } from 'tweetnacl-util';\nimport {\n  EventType,\n  IConnectParams,\n  IConnectRequestData,\n  IConnectResponseData,\n  IConnectResult,\n  InitialResponseListenerData,\n  IRejectResponse,\n  IRejectResult,\n  ISDKConstructor, ISignMessageRequestData, ISignMessageResponseData, ISignMessageResult,\n  ISignParams, ISignRequestData,\n  ISignResponseData,\n  ISignResult,\n  isResponseError,\n  SdkResponse,\n} from './interfaces';\nimport {\n  firstValueFrom,\n  of,\n  Subject,\n  Subscription,\n  switchMap,\n  take,\n  takeUntil,\n  throwError,\n  timer\n} from 'rxjs';\nimport { xBullSDK } from './mobile-sdk';\n\nexport class xBullWalletConnect {\n  closeCurrentPromises$: Subject<void> = new Subject<void>();\n  closeObservables$: Subject<void> = new Subject<void>();\n\n  preferredTarget: Required<ISDKConstructor['preferredTarget']>;\n\n  target?: Window | null;\n  targetPublicKey?: string; // this value is encrypted\n  readonly walletUrl: string;\n\n  encryptForReceiver: (params: { data: string, receiverPublicKey: Uint8Array }) => { message: string, oneTimeCode: string };\n  decryptFromReceiver: (params: { payload: string; oneTimeCode: string; senderPublicKey: string }) => string;\n  publicKey: () => Uint8Array;\n  session: () => string;\n\n  initialResponse$: Subject<MessageEvent<InitialResponseListenerData>> = new Subject<MessageEvent<InitialResponseListenerData>>();\n  initialResponseCompleted$: Subject<void> = new Subject<void>();\n\n  connectResponse$: Subject<MessageEvent<IConnectResponseData | IRejectResponse>> = new Subject<MessageEvent<IConnectResponseData | IRejectResponse>>();\n  connectResult$: Subject<IConnectResult | IRejectResult> = new Subject<IConnectResult | IRejectResult>(); // the value is the public key returned from the wallet\n\n  signResponse$: Subject<MessageEvent<ISignResponseData | IRejectResponse>> = new Subject<MessageEvent<ISignResponseData | IRejectResponse>>();\n  signResult$: Subject<ISignResult | IRejectResult> = new Subject<ISignResult | IRejectResult>();\n\n  signMessageResponse$: Subject<MessageEvent<ISignMessageResponseData | IRejectResponse>> = new Subject<MessageEvent<ISignMessageResponseData | IRejectResponse>>();\n  signMessageResult$: Subject<ISignMessageResult | IRejectResult> = new Subject<ISignMessageResult | IRejectResult>();\n\n  constructor(params?: ISDKConstructor) {\n    this.preferredTarget = params?.preferredTarget || 'extension';\n    this.walletUrl = params?.url || 'https://wallet.xbull.app/connect';\n    const sessionKeypair = box.keyPair();\n    const session = encodeBase64(randomBytes(24));\n\n    this.encryptForReceiver = (params: { data: string, receiverPublicKey: Uint8Array }) => {\n      const oneTimeCode = randomBytes(24);\n      const cipherText = box(\n        decodeUTF8(params.data),\n        oneTimeCode,\n        params.receiverPublicKey,\n        sessionKeypair.secretKey\n      );\n\n      return {\n        message: encodeBase64(cipherText),\n        oneTimeCode: encodeBase64(oneTimeCode),\n      };\n    };\n\n    this.decryptFromReceiver = (params: { payload: string; oneTimeCode: string; senderPublicKey: string }) => {\n      const decryptedMessage = box.open(\n        decodeBase64(params.payload),\n        decodeBase64(params.oneTimeCode),\n        decodeBase64(params.senderPublicKey),\n        sessionKeypair.secretKey,\n      );\n\n      if (!decryptedMessage) {\n        throw new Error('Decrypted message is null');\n      }\n\n      return encodeUTF8(decryptedMessage);\n    }\n\n    this.publicKey = () => sessionKeypair.publicKey;\n\n    this.session = () => session.slice();\n\n    const listener = (ev: any) => {\n      switch (ev.data.type as EventType) {\n        case EventType.XBULL_INITIAL_RESPONSE:\n          this.initialResponse$.next(ev);\n          break;\n\n        case EventType.XBULL_CONNECT_RESPONSE:\n          this.connectResponse$.next(ev);\n          break;\n\n        case EventType.XBULL_SIGN_RESPONSE:\n          this.signResponse$.next(ev);\n          break;\n\n        case EventType.XBULL_SIGN_MESSAGE_RESPONSE:\n          this.signMessageResponse$.next(ev);\n          break;\n      }\n    };\n\n    window.addEventListener('message', listener);\n\n    this.closeObservables$.asObservable()\n      .pipe(take(1))\n      .subscribe(() => {\n        window.removeEventListener('message', listener);\n      });\n  }\n\n  closeCurrentPromisesSubscription: Subscription = timer(1000, 1000)\n    .pipe(takeUntil(this.closeObservables$))\n    .subscribe(() => {\n      if (this.target?.closed) {\n        this.closeCurrentPromises$.next();\n      }\n    })\n\n  onInititalResponseSubscription: Subscription = this.initialResponse$\n    .pipe(takeUntil(this.closeObservables$))\n    .subscribe((ev: MessageEvent<InitialResponseListenerData>) => {\n      const decryptedMessage = this.decryptFromReceiver({\n        oneTimeCode: ev.data.oneTimeCode,\n        payload: ev.data.message,\n        senderPublicKey: ev.data.publicKey\n      });\n\n      const data = JSON.parse(decryptedMessage);\n\n      if (data.providedSession === this.session()) {\n        this.targetPublicKey = ev.data.publicKey;\n        this.initialResponseCompleted$.next();\n      }\n    });\n\n  onConnectResponseSubscription: Subscription = this.connectResponse$\n    .pipe(takeUntil(this.closeObservables$))\n    .subscribe((ev: MessageEvent<IConnectResponseData | IRejectResponse>) => {\n      if (!this.targetPublicKey) {\n        this.connectResult$.next({ success: false, message: 'Wallet encryption public key is not provided, request rejected.' })\n        return;\n      }\n\n      if (!ev.data.success) {\n        this.connectResult$.next({ success: false, message: 'Request rejected from the wallet' });\n        return;\n      }\n\n      const decryptedMessage = this.decryptFromReceiver({\n        oneTimeCode: ev.data.oneTimeCode,\n        payload: ev.data.message,\n        senderPublicKey: this.targetPublicKey,\n      });\n\n      const data: { publicKey: string } = JSON.parse(decryptedMessage);\n\n      this.connectResult$.next({ success: true, publicKey: data.publicKey });\n    });\n\n  onSignResponseSubscription: Subscription = this.signResponse$\n    .pipe(takeUntil(this.closeObservables$))\n    .subscribe((ev: MessageEvent<ISignResponseData | IRejectResponse>) => {\n      if (!this.targetPublicKey) {\n        this.signResult$.next({ success: false, message: 'Wallet encryption public key is not provided, request rejected.' })\n        return;\n      }\n\n      if (!ev.data.success) {\n        this.signResult$.next({ success: false, message: 'Request rejected from the wallet' });\n        return;\n      }\n\n      const decryptedMessage = this.decryptFromReceiver({\n        oneTimeCode: ev.data.oneTimeCode,\n        payload: ev.data.message,\n        senderPublicKey: this.targetPublicKey,\n      });\n\n      const data: { xdr: string } = JSON.parse(decryptedMessage);\n\n      this.signResult$.next({ success: true, xdr: data.xdr });\n    });\n\n\n  onSignMessageResponseSubscription: Subscription = this.signMessageResponse$\n    .pipe(takeUntil(this.closeObservables$))\n    .subscribe((ev: MessageEvent<ISignMessageResponseData | IRejectResponse>) => {\n      if (!this.targetPublicKey) {\n        this.signMessageResult$.next({ success: false, message: 'Wallet encryption public key is not provided, request rejected.' })\n        return;\n      }\n\n      if (!ev.data.success) {\n        this.signMessageResult$.next({ success: false, message: 'Request rejected from the wallet' });\n        return;\n      }\n\n      const decryptedMessage = this.decryptFromReceiver({\n        oneTimeCode: ev.data.oneTimeCode,\n        payload: ev.data.message,\n        senderPublicKey: this.targetPublicKey,\n      });\n\n      const data: Omit<ISignMessageResult, 'success'> = JSON.parse(decryptedMessage);\n\n      this.signMessageResult$.next({ success: true, ...data });\n    });\n\n  openWallet() {\n    if (!!this.target && !this.target.closed) {\n      this.target.close();\n      this.target = null;\n      this.closeCurrentPromises$.next();\n    }\n\n    this.target = window.open(\n      `${this.walletUrl}?public=${encodeURIComponent(encodeBase64(this.publicKey()))}&session=${encodeURIComponent(this.session())}`,\n      'xBull_Wallet_app',\n      'width=380,height=640,left=100,top=100'\n    );\n\n    return firstValueFrom(\n      this.initialResponseCompleted$\n        .pipe(takeUntil(this.closeCurrentPromises$))\n        .pipe(takeUntil(this.closeObservables$))\n    );\n  }\n\n  closeWallet() {\n    if (!!this.target) {\n      this.target?.close();\n      this.target = null;\n    }\n  }\n\n  async connect(params: IConnectParams = { canRequestPublicKey: true, canRequestSign: true }): Promise<string> {\n    const extensionSdk: xBullSDK = !!(window as any)?.webkit?.messageHandlers?.cordova_iab ? new xBullSDK() : (window as any).xBullSDK;\n    if (!!extensionSdk && this.preferredTarget === 'extension') {\n      const response: SdkResponse<{ address: string }> = await extensionSdk.getAddress();\n\n      if (isResponseError(response)) {\n        throw response.error;\n      } else {\n        return response.address;\n      }\n    } else {\n\n      await this.openWallet();\n\n      if (!this.target || !this.targetPublicKey) {\n        throw new Error(`xBull Wallet is not open, we can't connect with it`);\n      }\n\n      const { message, oneTimeCode } = this.encryptForReceiver({\n        data: JSON.stringify(params),\n        receiverPublicKey: decodeBase64(this.targetPublicKey),\n      })\n\n      const payload: IConnectRequestData = {\n        type: EventType.XBULL_CONNECT,\n        message,\n        oneTimeCode,\n      };\n\n      this.target.postMessage(payload, '*');\n\n      const result = this.connectResult$\n        .asObservable()\n        .pipe(switchMap((result: IConnectResult | IRejectResult) => {\n          if (!result.success) {\n            this.closeWallet();\n            return throwError(() => new Error(result.message));\n          } else {\n            this.closeWallet();\n            return of(result.publicKey);\n          }\n        }))\n        .pipe(take(1))\n        .pipe(takeUntil(this.closeCurrentPromises$))\n        .pipe(takeUntil(this.closeObservables$));\n\n      return firstValueFrom(result);\n\n    }\n  }\n\n  async sign(params: ISignParams): Promise<string> {\n    const extensionSdk: xBullSDK = !!(window as any)?.webkit?.messageHandlers?.cordova_iab ? new xBullSDK() : (window as any).xBullSDK;\n    if (!!extensionSdk && this.preferredTarget === 'extension') {\n      const response = await extensionSdk.signTransaction({\n        xdr: params.xdr,\n        opts: {\n          networkPassphrase: params.network,\n          address: params.publicKey,\n        }\n      });\n\n      if (isResponseError(response)) {\n        throw response.error;\n      } else {\n        return response.signedTxXdr;\n      }\n    } else {\n      await this.openWallet();\n\n      if (!this.target || !this.targetPublicKey) {\n        throw new Error(`xBull Wallet is not open, we can't connect with it`);\n      }\n\n      if (typeof params.xdr !== 'string') {\n        throw new Error('XDR provided needs to be a string value');\n      }\n\n      const { message, oneTimeCode } = this.encryptForReceiver({\n        data: JSON.stringify(params),\n        receiverPublicKey: decodeBase64(this.targetPublicKey),\n      });\n\n      const payload: ISignRequestData = {\n        type: EventType.XBULL_SIGN,\n        message,\n        oneTimeCode,\n      };\n\n      this.target.postMessage(payload, '*');\n\n      const result = this.signResult$\n        .asObservable()\n        .pipe(switchMap((result: ISignResult | IRejectResult) => {\n          if (!result.success) {\n            this.closeWallet();\n            return throwError(() => new Error(result.message));\n          } else {\n            this.closeWallet();\n            return of(result.xdr);\n          }\n        }))\n        .pipe(take(1))\n        .pipe(takeUntil(this.closeCurrentPromises$))\n        .pipe(takeUntil(this.closeObservables$));\n\n      return firstValueFrom(result);\n    }\n  }\n\n  async signMessage(\n    message: string,\n    opts?: {\n      networkPassphrase?: string,\n      address?: string;\n    }\n  ): Promise<{ signedMessage: string; signerAddress: string}>  {\n    const extensionSdk: xBullSDK = !!(window as any)?.webkit?.messageHandlers?.cordova_iab ? new xBullSDK() : (window as any).xBullSDK;\n    if (!!extensionSdk && this.preferredTarget === 'extension') {\n      const response = await extensionSdk.signMessage(message, opts);\n\n      if (isResponseError(response)) {\n        throw response.error;\n      } else {\n        return response;\n      }\n    } else {\n      await this.openWallet();\n\n      if (!this.target || !this.targetPublicKey) {\n        throw new Error(`xBull Wallet is not open, we can't connect with it`);\n      }\n\n      if (typeof message !== 'string') {\n        throw new Error('XDR provided needs to be a string value');\n      }\n\n      const encrypted = this.encryptForReceiver({\n        data: JSON.stringify({ message, opts }),\n        receiverPublicKey: decodeBase64(this.targetPublicKey),\n      });\n\n      const payload: ISignMessageRequestData = {\n        type: EventType.XBULL_SIGN_MESSAGE,\n        message: encrypted.message,\n        oneTimeCode: encrypted.oneTimeCode,\n      };\n\n      this.target.postMessage(payload, '*');\n\n      const result = this.signMessageResult$\n        .asObservable()\n        .pipe(switchMap((result: ISignMessageResult | IRejectResult) => {\n          if (!result.success) {\n            this.closeWallet();\n            return throwError(() => new Error(result.message));\n          } else {\n            this.closeWallet();\n            return of({\n              signedMessage: result.signedMessage,\n              signerAddress: result.signerAddress\n            });\n          }\n        }))\n        .pipe(take(1))\n        .pipe(takeUntil(this.closeCurrentPromises$))\n        .pipe(takeUntil(this.closeObservables$));\n\n      return firstValueFrom(result);\n    }\n  }\n\n  closeConnections() {\n    this.closeObservables$.next();\n    this.closeCurrentPromises$.next();\n    this.closeObservables$.complete();\n    this.closeCurrentPromises$.complete();\n  }\n}\n"],"names":["xBullWalletConnect","constructor","params","this","closeCurrentPromises$","Subject","closeObservables$","initialResponse$","initialResponseCompleted$","connectResponse$","connectResult$","signResponse$","signResult$","signMessageResponse$","signMessageResult$","closeCurrentPromisesSubscription","timer","pipe","takeUntil","subscribe","target","closed","next","onInititalResponseSubscription","ev","decryptedMessage","decryptFromReceiver","oneTimeCode","data","payload","message","senderPublicKey","publicKey","JSON","parse","providedSession","session","targetPublicKey","onConnectResponseSubscription","success","onSignResponseSubscription","xdr","onSignMessageResponseSubscription","preferredTarget","walletUrl","url","sessionKeypair","box","keyPair","encodeBase64","randomBytes","encryptForReceiver","cipherText","decodeUTF8","receiverPublicKey","secretKey","open","decodeBase64","Error","encodeUTF8","slice","listener","type","EventType","XBULL_INITIAL_RESPONSE","XBULL_CONNECT_RESPONSE","XBULL_SIGN_RESPONSE","XBULL_SIGN_MESSAGE_RESPONSE","window","addEventListener","asObservable","take","removeEventListener","openWallet","close","encodeURIComponent","firstValueFrom","closeWallet","connect","canRequestPublicKey","canRequestSign","extensionSdk","webkit","messageHandlers","cordova_iab","xBullSDK","response","getAddress","isResponseError","error","address","stringify","XBULL_CONNECT","postMessage","result","switchMap","of","throwError","sign","signTransaction","opts","networkPassphrase","network","signedTxXdr","XBULL_SIGN","signMessage","encrypted","XBULL_SIGN_MESSAGE","signedMessage","signerAddress","closeConnections","complete"],"mappings":"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"}